概述
当我们进行技术评估时，经常会对比多种技术方案，最终需要选出哪个方案最合适。以往我们没有一个共识的标准，往往是从主观判断上进行一个选择。而每个人的主观判断往往不一致，所以希望这个评估标准能让大家达成某种程度的共识，让评估更有据可依。

这个标准是为技术评审服务的，技术评审则务必符合该标准，技术评审不存在则该标准也不存在。
标准说明
1. 设计合理性
2. 稳定性
3. 可用性
4. 可维护性
5. 工作量
设计合理性
首先第一条我们就需要确认技术方案的设计是否合理，是否有致命缺陷，是否不符合一些技术设计原则。如果设计压根不合理，那后续的评估都没有任何意义。

这里列出一些基本的设计原则：
1. 简洁性：设计应该尽可能简洁，避免不必要的复杂度和冗余。简洁的设计可以使系统更容易理解和维护。
2. 可扩展性：设计应该具有良好的扩展性，以便随着业务的发展和变化而扩展和调整系统。这可以减少重构和重写的需求，节省开发成本和时间。
3. 模块化：设计应该采用模块化的方式，将系统分解成相互独立的模块，每个模块都具有明确的功能和职责。这可以使系统更容易维护、测试和扩展。
4. 可重用性：设计应该具有良好的可重用性，以便在不同的场景下可以重复使用某些组件或模块。这可以减少重复开发的工作量，提高开发效率和质量。
5. 可靠性：设计应该具有良好的可靠性和健壮性，以便系统能够在面对各种异常情况时依然保持稳定运行。
6. 性能和可用性：设计应该具有良好的性能和可用性，以便系统能够快速响应用户的需求和操作。

并不是越复杂的设计越牛逼，而是越简洁的设计越牛逼。设计的越复杂，稳定性会越低。优秀的软件应该保持简洁的设计，简洁不代表简单。简洁指的是在架构上模块化，各模块职责清晰，各司所知。系统整体很复杂，但是很简洁，将复杂度收敛到各自模块中。
评分标准
100: 没有违反任何设计原则
80: 违反了 1 个设计原则
60: 违反了 2 个设计原则
40: 违反了 3 个以上设计原则

Badcase:
1. 一个方案想解决所有问题
2. 想得太多，过度设计
3. 没有抽象，耦合严重
4. 不可水平伸缩，造成性能低下
- fission executor 单点
5. 缺乏可测试性，构建自动化测试困难

稳定性
影响稳定性的因素如下
1. 人为因素：不合理的变更、外部攻击等等
2. 软件因素：代码bug、设计漏洞、GC问题、线程池异常、上下游异常
3. 硬件因素：网络故障、机器故障等

在技术方案的评估中，我们主要评估设计上有没有导致稳定性问题的设计漏洞。
评分标准:
100: 无任何影响稳定性的设计漏洞
80: 有稳定性设计漏洞，但有可靠的兜底策略
50: 有稳定性设计漏洞，但有不可靠的兜底措施
0: 有任何一个影响稳定性的设计漏洞
Badcase: todo~
可用性最重要的就是：可访问，不报错。因此，我们就可以评估在系统设计中的请求数据路径是否有影响可用性的因素。这里提出几个判断标准：
1. 请求路径中的逻辑是否依赖外部系统？
2. 如果依赖外部系统，是否有降级措施？
评分标准:
100: 不依赖外部系统且有方案保证发生 BUG 或错误也不影响可用性
80: 不依赖外部系统，没有思考如何保证高可用
60: 依赖外部系统但有降级措施
40: 依赖外部系统且无降级措施
Badcase

可维护性
大型软件或公司软件都是团队协作进行开发的，当多人协作时代码的可维护性就异常重要。因为你写的代码不可能一直由你自己维护，你写的代码也会跟别人的代码产生交集。如果你写的代码只有你自己能看懂，那你写的代码就不具备可维护性。
那么什么情况下我们会觉得一个项目不好维护或好维护？
其实我们对一个项目好不好维护的评价不完全是客观的。我们从可以从上面四个维度来进行划分，其中左边是跟个人相关的，右边的是跟项目相关的。理解能力属于个人学习能力，熟悉度属于个人对目标项目的了解程度；理解能力越强，越不容易觉得维护成本高；对项目越熟悉，哪怕是屎山代码，也会觉得别人重构后可维护性并不会提高，因为自己对项目会变得不熟悉。

业务复杂度是由目标项目涉及到的业务决定的，代码质量是由目标项目作者的编码水平决定的。业务本身越复杂，维护成本就会越高，因为信息量不可避免的增大了，我们永远不能只盯着 Hello World 的 Demo 研究框架；代码质量体现了技术对业务的抽象，抽象的好，复杂度曲线就会比较贴合业务真实复杂度，抽象的不好，Hello World Demo 也能够新人进来喝一壶。

代码的可维护性越高，软件的生命周期会越长。一个优秀的程序员应该以写出或参与生命周期更长的软件开发工作而骄傲，而不是以写了多少软件的数量或速度而骄傲。

因此，代码可维护性要从这四个方面来进行保证。
1. 理解能力：鼓励组内成员多阅读优秀的开源项目，定期进行优秀设计的分享。
2. 熟悉度：每个项目指定一名 Owner，两名 Reviewer。三人必须对该项目完全熟悉。
3. 业务复杂度：严把关，每个需求都要追问到底，避免 XY 问题，只做真实需求，从而控制业务复杂度的上升。
4. 代码质量：严格遵循工程实践规范（DRAFT），所有开发工作走 MR 流程，必须通过单测、lint 和 sonar 扫描，并经过最少一名 Reviewer 的 Review。
评分标准,评分主要从客观角度进行评价，所以我们只基于 3 和 4 进行评价:
100: 降低了业务复杂度，提升了代码质量
80: 业务复杂度没有发生变化，提升了代码质量
60: 业务复杂度变高了，代码质量没变或降低了
50: 业务复杂度变高了，代码质量也降低了
工作量
工作量的单位是「人天」，即 1 个人 1 天做的工作量。我们需要把不同方案的工作量进行量化，列出不同方案的各种工作项，针对每个工作项给出工作量评估。最终把所有工作量进行累加得出总工作量和大概的持续时间。

常见的工作量如下：
1. 开发 xx 功能
2. 修复 xx 问题
3. 测试 xx 功能
4. 迁移 xx 存量数据
5. 基于这个方案后续迭代 yy 功能
6. yy 功能的测试

成本与收益汇总：TODO（收益该如何量化?）
方案 A 综合评分 B，方案 B 综合得分 A。
方案 A 总投入成本 70 人天，方案 B 总投入 40 人天。
方案 A 的收益是解决了当下的问题，方案 B 的收益是更低的投入和长远的质量保证。
评估步骤
1. 作者给出自己的各项评估。
2. 作者邀请团队成员进行挑战。
3. 团队成员对作者给出的不同技术方案的评估进行质疑、修正，最终达成共识。
4. 对共识后的结果进行汇总，得到最优方案。
5. 如果评估结果相近，由项目负责人最终决定使用哪个方案。
   参考文章
- 对比 Availability 可用性、Reliability 可靠性、Stability 稳定性 - 蝈蝈俊 - 博客园
- https://cloud.google.com/architecture/devops/devops-tech-code-maintainability?hl=zh-cn
- 精读《可维护性思考》 - 掘金
- 顶层设计的原则包括-掘金
